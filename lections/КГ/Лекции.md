## Лекция 1

> Формат названий лабораторных: Лабораторная работа № 1. Фамилия Имя Отчество. Компьютерная графика.doc

### Краткая история развития компьютерной графики

**Компьютерная графика** - это наука, которая изучает методы преобразования трехмерных объектов в двумерные изображения.
Исторически появление компьютерной графики связано с пакетом Сазерленда в 1962 году. Сазерленд написал программу Sketchpad, которая позволяла изображать на экране простейшие трехмерные объекты.
В 60-е годы появились алгоритмы формирования теней и удаления невидимых поверхностей.
В 70-е годы появились рабочие станции, которые объединили: технологии ввода-вывода, технологии связи и технологии работы с графическими объектами. В это время появляется трехмерная графика.
В 80-е годы появились технологии мультимедиа, т.е., к обработке графики добавился звук и видеоизображение.
С 90-х годов по наши дни - развитие реалистичной графики, имитирующей реальный мир.
2018-2019 гг. - Использование технологии трассировки лучей в режиме реального времени.
В наше время активно развиваются технологии виртуальной реальности и дополненной реальности.

Технологии компьютерной графики сочетают в себе математические методы (геометрия и мнимая алгебра) работы с объектами и методы аппаратного ускорения.

### Аппаратные способы реализации алгоритмов компьютерной графики.

- Растровый способ
   Для растровых изображений характерен способ его хранения в виде матрицы цветных точек (пикселей)
   Растровые методы включают в себя целочисленные методы построения линий, закраски многоугольников и эллипсов.
   
- Трассировка лучей

   

### Виды компьютерной графики (по способу хранения изображения)

- Растровая графика
   Изображение хранится в виде матрицы, цвет каждой ячейки кодируется тремя байтами.
   Хранится в файлах BMP (bitmap image); или со сжатием - например, *.jpeg

- Векторная графика
   Векторные форматы используются в 3д-моделировании, CAD итд.
   В векторном методе изображение представляется в виде совокупности отрезков, дуг итд. В общем случае вектор - это набор данных о каком-либо объекте. Векторные изображения хорошо масштабируются, в отличие от растровых, но практически не позволяют получать изображения фотографического качества. Векторные изображения занимают в памяти объем, пропорциональный количеству примитивов, объем такого изображения в байтах не зависит напрямую от размера самого изображения.

- Фрактальная графика
   Изображение строится по уравнениям, поэтому хранятся только формулы. Можно эмулировать образы живой природы, воды, ткани, дерева, текстур итд.

## Лекция 2

### Основные графические объекты Qt

1. Перо (QPen) - задает стиль рисования контура фигур. Свойства: цвет, толщина линии, тип линии. 
2. Кисти (QBrush) - определяет стиль заполнения фигуры, цвет заливки и тип штриховки.
3. Цвет - чаще всего задается в формате RGB или RGBA. Каждый из каналов задается числом от 0 до 255 (для альфа-канала 255 - непрозрачная фигура). Также можно задавать в виде HSV (Hue, Saturation, Value). H - 0-359; S, V - 0-100. H - основной тон, S - насыщенность, чем больше - тем чище цвет. Модель HSV была создана одним из основателей PIXAR. 
4. Для удобства работы с точками и прямоугольниками в qt предусмотрены QPoint, QPointF, QRect, QRectF. По сути класс QPoint хранит только координаты точки в целочисленном виде, а QPointf - в вещественном виде. QRect - то же самое, но с прямоугольником на плоскости. top(), left(), bottom(), right() возвращают расстояние от границ экрана, width(), height() - габариты прямоугольника
5. Для рисования используется класс QPainter, содержащий методы для рисования примитивов, инициализации кистей, перьев, цветов и т. д.

### Экранная и мировая система координат

При работе с графическими приложениями обычно используют две системы координат:

- мировую систему координат.
- экранную систему координат - систему координат окна приложения.

Единицами измерения здесь является номер пикселя.

ТУТ КАРТИНКА НО Я НЕ ХОЧУ ЕЕ РИСОВАТЬ

там в общем прямоугольник, слева вверху 0, 0.
внутри еще один прямоугольник в котором нарисован график функции
суть в том, что график функции выражен в мировой системе координат, а в общем прямоугольнике используется экранная система координат.

Мировая система координат - это система координат, связанная с решаемой задачей; единицей измерения в ней может быть, к примеру, метр.

Чтобы перевести мировые координаты в экранные, надо $X=X_1+\frac{x-x_1}{x_2-x_1}(X_2-X_1)$; $Y=Y_2-\frac{y-y_1}{y_2-y_1}(Y_2-Y_1)$

Внутри Qt удобно хранить координаты с помощью класса QRect.

## Лекция 3

Предпочтительный шаг разметки - это расстояние между двумя соседними разметками H (в пикселях).

H = 100 пикселей
$h = 1*10^n, 2*10^n,5*10^n$ 

Действительный шаг в общем случае не равен H, но выбираться он будет таким образом, чтобы при пересчете в мировые координаты полученный шаг был наиболее близок к одному из доступных значений h.

 Пускай $H = 150, x\in [50, 200], w = 1000$. Тогда $h = \frac{H}{W}(x_2-x_1) = 22,5$. К этому значению ближе всего $h=2*10^1 = 20, m = 2, n = 1$. Тогда $H' = 20 * \frac{W}{x_2-x_1} = 20000/150 = 133\frac{1}{3}$ - действительный шаг разметки. $x'_1 = (\lfloor\frac{x_1}{h}\rfloor+1)*h = (\lfloor\frac{30}{20}\rfloor+1)*20 = 60$. Разметка будет 60, 80, 100, 120, …

Можно приравнять возможные значения h к h* и решить три уравнения с неизвестными n_1, n_2, n_5 и выбрать наименьшее значение из следующих шести значений: $h^* - 10^{\lfloor n_1\rfloor}, 10^{\lceil n_1\rceil} - h^*, h^* - 2 * 10^{\lfloor n_1\rfloor}, 2 * 10^{\lceil n_1\rceil} - h^*, h^* - 5 * 10^{\lfloor n_1\rfloor}, 5 * 10^{\lceil n_1\rceil} - h^*$

Для вычисления шагов разметки необходима отдельная функция.

step(double &k, double * H, int &m, int &n)
вход
$k = \frac{W}{b-a}$

выход

$k = h, k = m * 10^2$

k - действительный шаг разметки в мировой системе координат, H - действительный шаг разметки в мировой системе координат.

Все вычисления лучше производить с использованием вещественных чисел, чтобы не накапливались ошибки. Вещественные числа нужно округлять, когда риски будут закрашены на графике. Параметр n может помочь при округлении значения разметок. Если n < 0, то нужно оставить -n знаков после запятой. QString("%1").arg(s, 0, 'f', -n);

**Табулирование функций**

При рисовании графика количество линий на нем должно быть прямо пропорционально W. 

```
dx=(b-a)/W; x = a; QPoint P1, P2; converter; px = converter.X(x); PY = converter.Y(f(x)); 

for (int j = 1; j < W, j++){

x += dx;
P2X = converter.X(x);
P2Y=converter.Y(y);
painter.drawline(PX, PY, P2X, P2Y);
PX = P2X, PY = P2Y;
}
```

Столько линий, сколько содержится в одной строке по оси X (?). Для плавности можно увеличить в 2-4 раза.

## Лекция 4 

### Аффинные преобразования на плоскости

Афинные преобразования упрощают выполнения геометрических операций избавляя от необходимости выводить геометрические формулы для расчета сложных движений в пространстве.

В компьютерной графике рассматривают 4 аффинных преобразования:

* Поворот точки $A(x,y)$ вокруг начала координат на угол $\alpha$.

@todo График 4_1

> ВАЖНО. УМЕТЬ ВЫВОДИТЬ ФОРМУЛУ.

$$ x^* = x*\cos{\alpha}-y*\sin{\alpha}$$

$$y^* =x*\sin{\alpha}*y*cos{\alpha}$$

$$ \left( \begin{array}{ccc} x^*\\y^* \end{array} \right) = \left( \begin{array}{ccc} \cos{\alpha} ,-\sin{\alpha}\\\sin{\alpha}, \cos{\alpha} \end{array} \right) \left( \begin{array}{ccc} x \\ y \end{array} \right) $$

Если $\alpha = 0$ матрица становится единичной.

* Маштабирование относительно начала координат

  @todo График 4_2

  $$x^*=x*k_x$$

  $$y^* = y *k_y$$

* Перенос точки вдоль вектора $(\Delta x,\Delta y)$

  @todo График 4_3

$$x^*=x+\Delta x$$

$$y^* = y + \Delta y$$

* Отражение относительно оси абцисс и относительно оси ординат.

  @todo График 4_4

  $$ \left( \begin{array}{ccc} x^*\\y^* \end{array} \right) = \left( \begin{array}{ccc} 1,0\\0,-1 \end{array} \right) \left( \begin{array}{ccc} x \\ y \end{array} \right) $$

  $$ \left( \begin{array}{ccc} x^*\\y^* \end{array} \right) = \left( \begin{array}{ccc} -1,0\\0,1 \end{array} \right) \left( \begin{array}{ccc} x \\ y \end{array} \right) $$

  Операция переноса пока не выражена в матричном виде, данную операцию невозможно записать с использованием матриц размером $2*2$ , по этой причине переходят к матрицам размера $3*3$.

> Однородными координатами точки $(x,y)$ называют тройку чисел $(a:b:c)$ или $(x_1:x_2:k)$  которые связаны с исходными декартовыми координатами следующими соотношениями: $x = \frac{x_r}{k}$; $ y = \frac{x_2}{k}$

Использование однородных координат охватить матричными операциями все 4 аффинных преобразования.

Переход к однородным координатам сокращает количество операций деления в геометрических преобразованиях, что выгодно снижает вычислительные затраты. Операция деления заменяется умножением а последнее выполняется процессором гораздо быстрее.

Операция переноса в однородных координатах.

$$ \left( \begin{array}{ccc} x^*\\y^*\\1 \end{array} \right) = \left( \begin{array}{ccc} 1,0,\Delta x\\0,1,\Delta y\\0,0,1 \end{array} \right) \left( \begin{array}{ccc} x \\ y\\1 \end{array} \right) $$

Матрица поворота 

$$ \left( \begin{array}{ccc} x^*\\y^*\\1 \end{array} \right) = \left( \begin{array}{ccc} \cos{\alpha},-\sin{\alpha},0\\\sin{\alpha},\cos{\alpha},0\\0,0,1 \end{array} \right) \left( \begin{array}{ccc} x \\ y\\1 \end{array} \right) $$

Матрица масштабирования

$$ \left( \begin{array}{ccc} x^*\\y^*\\1 \end{array} \right) = \left( \begin{array}{ccc} k_x,0,0\\0,k_y,0\\0,0,1 \end{array} \right) \left( \begin{array}{ccc} x \\ y\\1 \end{array} \right) $$

Матрица масштабирования

$$ \left( \begin{array}{ccc} x^*\\y^*\\1 \end{array} \right) = \left( \begin{array}{ccc} 1,0,0\\0,-1,0\\0,0,1 \end{array} \right) \left( \begin{array}{ccc} x \\ y\\1 \end{array} \right) $$

Чтобы повернуть треугольник нужно выполнить преобразования:

1.  Перенос всех точек вдоль вектора.
2. Поворот всех точек треугольника на угол $\alpha$
3. Перенос всех точек вдоль вектора $()$

```c++
class Matrix3x3{
    static Matrix3x3
        rotate(float angle){
        Matrix3x3 M;
        M.m[0][0] = ...
        return M;
    }
}

Matrix3x3 R = Matrix3x3::rotate(30);
// Все матрицы:
scale(float kx, float ky);
translate(float dx, float dy);
reflectionX();
reflectionY();
```

Операции над матрицами размера 3x3 лучше реализовать без циклов для большего быстродействия.

```c++
Matrix3x3 R, M1, M2;
QVector3D V1[16], v2[16];
...
// Здесь лучше умножить матрицы, а потом уже формировать вектор
Matrix3x3 D = M1*R*M2;
for (int i = 0; i<16; i++){
    V2[i] = P*V[i];
}
```

При выполнении аффинных преобразований необходимо по возможности предварительно выполнить умножение матриц. 

```asm
start:
do huyna
loop start
```

##### Аффинные преобразования в пространстве.

Введем однородные координаты в трехмерном пространстве. Заменим координатную тройку x, y, z четверкой чисел (hx, hy, hz, k). Однородные координаты связаны с обычными следующими соотношениями: $x=\frac{hx}{k}$, $y=\frac{hy}{k}$, $z=\frac{hz}{k}$. $k\ne 0$. Данный переход дает возможность воспользоваться матричной записью в более сложных трехмерных задачах. Любое аффинное преобразование в трехмерном пространстве может быть представлено в виде комбинации вращения, растяжения и переносов. Матрицы этих преобразований:

1. Матрица вращения, или поворота вокруг оси абсцисс
   $$R_x = \left( \begin{array}{ccc} 1,0,0,0\\0,\cos{\alpha},-\sin{\alpha}, 0\\0,\sin{\alpha},\cos{\alpha},0\\0,0,0,1 \end{array} \right) \left( \begin{array}{cccc} x\\y\\z\\1 \end{array} \right)$$

2. Матрица вращения вокруг оси ординат
   $$R_y = \left( \begin{array}{ccc} 
   \cos{\beta},0,-\sin{\beta},0\\
   0,1,0,0\\
   \sin{\beta},0,\cos{\beta},0\\0,0,0,1 \end{array} \right) \left( \begin{array}{cccc} x\\y\\z\\1 \end{array} \right)$$

3. Матрица вращения вокруг оси аппликат
   $$R_z = \left( \begin{array}{ccc} \cos{\gamma},\sin{\gamma},0,0\\-\sin{\gamma},\cos{\gamma},0, 0\\0,0,1,0\\0,0,0,1 \end{array} \right) \left( \begin{array}{cccc} x\\y\\z\\1 \end{array} \right)$$

4. Матрица растяжения (сжатия)
   $$D = \left( \begin{array}{ccc} 
   k_x,0,0,0\\
   0,k_y,0,0\\
   0,0,k_z,0\\
   0,0,0,1
   \end{array} \right) \left( \begin{array}{cccc} x\\y\\z\\1 \end{array} \right)$$

5. Матрица переноса

   $$D = \left( \begin{array}{ccc} 
   1,0,0,d_x\\
   0,1,0,d_y\\
   0,0,1,d_z\\
   0,0,0,1
   \end{array} \right) \left( \begin{array}{cccc} x\\y\\z\\1 \end{array} \right)$$

6. Матрица отражения (Плоскость $O_{xy}$)
   $$R_{xy} = \left( \begin{array}{ccc} 
   1,0,0,0\\
   0,1,0,0\\
   0,0,-1,0\\
   0,0,0,1
   \end{array} \right) \left( \begin{array}{cccc} x\\y\\z\\1 \end{array} \right)$$

7. Матрица отражения (Плоскость $O_{xz}$)
   $$R_{xz} = \left( \begin{array}{ccc} 
   1,0,0,0\\
   0,-1,0,0\\
   0,0,1,0\\
   0,0,0,1
   \end{array} \right) \left( \begin{array}{cccc} x\\y\\z\\1 \end{array} \right)$$

```c++
QMatrix4x4::QMatrix4x4(const float *v){
    float m[16] = {
        cos(a), -sin(a), 0, 0,
		sin(a), cos(a), 0, 0,
        0, 0, 1, 0,
        0, 0, 0, 1
    };
    QMatrix R(m);
    float *data(); //Возвращает указатель на свободный массив, в котором записаны координаты
    double determinant(); //возвращает определитель матрицы
    void fill(float a); //Заполняет матрицу значениями a
    void rotate(float angle, const QVector3D &vector);
    // Умножает текущую матрицу на матрицу поворота. angle - угол поворота, второй параметр - вектор, вокруг которого поворачиваются точки
    QMatrix4x4 A;
    A.setToIdentity();
    A.rotate(30, QVector3D(1, 0, 0));
    
}

```

gruzchik

грузчик