## Лекция 1

### История развития вычислительной технический

#### **I** поколение ЭВМ (1950-е гг) было построено на базе электронных ламп
Электронная лампа - электровакуумный прибор, предназначенный для генерации, усиления и преобразования электрических сигналов.
Примеры систем: ENIAC, БЭСМ
Основоположник вычислительной техники в СССР - академик Лебедев С. А.

#### **II** поколение ведет историю с изобретения транзистора в 1948-м году.

> Транзистор - полупроводниковый прибор с тремя контактами, предназначенный для генерирования и преобразования электрических сигналов. Транзистор способен работать за 40 электронных ламп, с большей скоростью, потреблять меньше энергии.

Примеры систем: БЭСМ-6, Стретч (Англия), Атлас (США)
БЭСМ-6 состояла из 60 тыс. транзисторов и 180 тыс. диодов. Производительность - 1 млн операций в секунду.

#### **III** поколение - интегральные схемы.

> Одна интегральная схема может заменить несколько тысяч транзисторов (или несколько сорок тысяч ламп), обеспечивает стократный прирост производительности и уменьшение тепловыделения.

ИС изготавливают из особо чистых полупроводниковых материалов (кремний или германий). На основу наносятся химические элементы таким образом, что они образуют узлы сложной схемы.

#### **IV** поколение - сверхбольшие интегральные схемы (СБИС)

Технологический процесс определяет размер транзистора (затвора). В настоящее время освоена технология производства транзисторов от 5 нм.

Закон Мура. Гордон Мур сделал наблюдение, что каждые 18-24 месяца количество транзисторов в электронных устройствах возрастает вдвое.

#### **V** поколение ЭВМ
связывают с разработкой систем искуственного интеллекта и появлением квантовых процессоров

Быстродействие вычислительной системы в конечном итоге зависит от:
1. Технологии производства микросхем, процессоров, памяти, архитектуры.
2. Эффективности компиляторов

### Архитектура Джона фон Неймана

**Архитектура вычислительной системы** - это описание вычислительной системы на общем уровне, включающий систему команд, средства пользовательского интерфейса, организацию памяти. Архитектура определяет, из каких узлов будет состоять вычислительная система.

Абсолютное большинство вычислительных систем построены на архитектуре фон Неймана.

![Архитектура фон Неймана](files/l1pic1.png)

Центральный процессор состоит из двух блоков:
-   АЛУ (арифметико-логическое устройство)
-   УУ  (устройство управления)

Устройство управления определяет порядок выполнения процессором операций.
Арифметико-логическое устройство - блок процессора, который выполняет арифметические и логические операции.
УУ в каждый момент времени определяет, какую операцию выполнять следующей.

Устройство управления выбирает команды из оперативной памяти. Все данные для обработки попадают в процессор также через оперативную память.
## Лекция 2

### Принципы функционирования центрального процессора

**Машинная команда** - это описание операции, которую должна выполнить ЭВМ, закодированное в двоичном виде. Содержит выполняемые операции и коды операндов (адреса ячеек оперативной памяти). Команды бывают следующих видов: 

1. Арифметические (сложение, вычитание, умножение, деление - ADD, SUB, MUL, DIV)
2. Логические (и, или, исключающее или, отрицание - AND, OR, XOR, NOT)
3. Команды ввода-вывода (ввод, вывод с помощью портов - IN, OUT)
4. Команды перехода и вызова подпрограмм (JMP, CALL,LOOP, JLE, JOP, и т. д.)
5. Команды для работы с прерываниями

Совокупность операций, выполняемых процессором, называется *система команд*.  Мы будем изучать систему команд x86.

**Регистры** - это ячейки быстродействующей памяти, расположенные непосредственно на кристалле процессора. 

картинка 1

Аналогичную структуру имеют регистры **RBX, RCX, RDX**. В 64-битной архитектуре добавлены восемь новых регистров: **R0-R7**. 

### Работа с регистрами

Очищать регистры можно с помощью XOR. XOR EAX, EAX даст 0 в EAX. Эта команда занимает меньше места и выполняется быстрее, чем MOV EAX, 0. Чтобы заполнить регистр единицами, можно записать в него 0FFFFFFFFh - самое большое возможное число.

Пара примеров:

```asm
MOV EAX, 0FFFFFFFFh

ADD EAX, 1 ; EAX = 000000000h, т.к. произошел перенос

ADD AX, 1 ; EAX = 0FFFF0000h, т.к. произошел перенос (но мы работали с 16-ричным разрядом).
```

При возникновении переноса устанавливается флаг переноса CF.

Надо помнить, что 16-ричной системе счисления 1 байт = 2 цифры. $FF_{16}=255_{10}$. Тетрада - набор из четырех бит, обозначается одной шестнадцатеричной цифрой.

Любая команда процессора работает только с той частью регистра, которая указана в ее описании. 

Программисту доступны регистры общего назначения EAX, EBX, ECX, EDX, индексные ESI, EDI и регистр EBP. Индексные регистры чаще используют для работы с массивами, в них записывают адреса ячеек оперативной памяти. EBP обычно используется компиляторами для адресации аргументов функций и локальных переменных, но программист может их использовать по собственному усмотрению. ESP - указатель на вершину стека. 

#### Назначение стека

1. В стеке хранятся локальные переменные
2. При вызове подпрограмм в стек сохраняется адрес возврата из подпрограммы.
3. В стек обычно передаются аргументы подпрограммы.

Размер стека небольшой, порядка нескольких мегабайт.

**EIP** указывает на текущую выполняемую инструкцию, увеличивается на размер выполненной команды.

**EFLAGS** - 32-битный регистр, который содержит несколько флагов - переноса, переполнения, четности, направления, трассировки и другие. 
**Флаг** - однобитный регистр, в котором сохраняется информация о выполнении последней команды. То есть, флаги отражают текущее состояние процессора. 

**Сегментные регистры** - шестнадцатиразрядные регистры.

- CS (code segment) содержит номер сегмента кода, с которым работает программа.
- DS (data segment) - номер сегмента данных
- SS (stack segment) - номер сегмента стека
- ES
- FS

В операционной системе Windows используется сплошная модель памяти, поэтому данные, код и стек располагаются в одном адресном пространстве.

#### Директивы для определения переменных:

Типы данных:

- DB - 1 байт, char
- DW - 2 слово, short
- DD - 4 двойное слово, int
- DF - 6 тройное слово long double
- DQ - 8 учетверенное слово, long long
- DT - 10 упятеренное слово

Вещественные числа могут храниться как четырехбайтовые и восьмибайтовые. Некоторые команды процессора требуют указания размера аргумента. (Аналог приведения типа). Для этого используются  директивы приведения типа:

- byte ptr - 1 байт
- word ptr - слово
- dword ptr - 4 байта
- qword ptr - 8 байт

## Лекция 3

### Виды адресации

1. Непосредственная адресация
   MOV EAX, 10
   Непосредственную адресацию здесь имеет операнд 10. EAX - регистровая адресация.
2. Регистровая адресация
   ADD ESI, EDI
   Оба операнда имеют регистровую адресацию.
3. Прямая адресация
   В данном случае операнд располагается в оперативной памяти.
   MOV EAX, [04001002]
   c dd 6
   MOV EBX, c
   Два способа выше эквивалентны, т.к. вместо переменной c подставляется адрес в памяти
4. Базовая адресация
   Адрес ячейки записан в одном регистре
   MOV ESI, [EBX]
   В ассемблере невозможны команды, при которых обе ячейки имеют базовую адресацию. Один из операторов обязательно должен иметь либо регистровую адресацию, или  непосредственную.
   char a[]={1,2,3}
   MOV ESI, offset a
   MOV a, ESI
   MOV AL, a[0]
   MOV AL, [ESI]
5. Базово-индексная адресация
   В формировании адреса участвуют два регистра.
   MOV ESI, [EBX+EDI]
   Такая адресация полезна при адресации массивов.
6. Базово-индексная с масштабированием
   MOV ESI, [EBX+EDI * 4]
   То же, что и 5, но прибавляемое значение умножается.
   Масштабный множитель может быть равен 1, 2, 4 либо 8
   int a = {1, 2, 3}
   MOV ESI, offset a
   LEA ESI, [EAX+EAX * 4]; ESI = EAX+EAX * 4 = EAX * 5
   Такой способ удобен для обхода массивов для типов char, short, int, float, double
   a dd 1, 2, 3, 4 ; один элемент занимает 4 байта
   MOV EAX, a ; запишется 1
   MOV EAX, a[0] ; то же самое
   MOV EBX, a[4] ; запишется 2

В оперативной памяти байты чисел хранятся по следующему правилу: младший байт - по младшему адресу, т.е., порядок Little Endian.
Если необходимо получить в регистре адрес ячейки памяти, можно использовать директиву offset. Запишем в ESI адрес массива a:
MOV ESI, offset a.

Если нужно сохранить данные в виде матрицы, необходимо представить ее в виде массива, в таком виде записать ее в памяти и интерпретировать как матрицу.

### Арифметические команды

Процессор не разделяет знаковые и беззнаковые числа в операциях сложения и вычитания. 
Процессор складывает числа в кольце целых чисел по модулю (2^8, 2^16, 2^32). 
При работе со знаковыми числами пользователь (программист) сам интерпретирует числа со старшим единичным битом как отрицательные.

ADD <операнд1>, <операнд2>
Складывает два операнда
ADC <операнд1>, <операнд2>
Кроме сложения операндов добавляет флаг CF.

```asm
MOV AL, 255
XOR BL, BL
ADD AL, 2 ; AL = 1, CF = 1
ADC BL, 0 ; BL = 1
```

INC <операнд>
Инкрементирует операнд, при переполнении устанавливает флаг

Эти команды складывают как числа со знаком, так и без знака.

SUB <операнд1>, <операнд2> - вычитание
SBB <операнд1>, <операнд2> - вычитание со знаком переноса
DEC <операнд> - декремент

## Лекция ?

#### Умножение чисел типа unsigned long long

-сраки горят
-может, сроки?
-нет

```asm
a dq 5
b dq 0FFFFFFFFh
r db 16 dup(?)
MOV r[1], c[1]
ADD r[1], d[1]
ADC r[2], 0
ADC r[3], 0
ADD r[1], e[1]
ADC r[2], 0
ADC r[3], e[1]
```

```
             a1a0
            *b1b0
       a0*b0=c1c0
     b1*a0=d2d1
     b0*a1=e2e1
   a1*b1=f3f2
=f3+CF d2+e2+f2+CF c1+d1+e1+CF c0 
```

### Команды передачи управления

Передача управления - это изменение адреса текущей инструкции (EIP) на то значение адреса, которое закодировано в коде команды как адрес для перехода либо как смещение значения EIP. Например, LOOP (EIP +/- = 127) В отличие от команд передачи управления, остальные команды просто увеличивают значение EIP на длину текущей команды. 

1. Команда безусловного перехода: JMP <метка>. Команда безусловного перехода передает управление по метке вне зависимости от установленных флагов.
2. Команды условного перехода (JZ и др.) передают управление метке, если условие выполняется, или следующей за ней команде, если условие не выполняется. JZ - результат выполнения предыдущей команды равен 0. 

Флаги:

CF - флаг переноса - 1, если возникает перенос из старшего разряда.

OF - флаг переполнения - 1, при переносе из предпоследнего разряда в последний (смена знака). 

```asm
MOV AL, 01111111b
ADD AL, 1 ; Меняется знаковый бит - возникает перенос. Флаг OF устанавливается в 1
```

EF - флаг ошибки - 1, если результат выполнения команды равен 0

```asm
MOV EAX, 5
SUB EAX, 5
```

SF - дублирует значение старшего знакового бита. 

```asm
XOR EAX, EAX
ADD AL, 1; SF = 0
SUB AL, 2; SF = 1
```

Часто команды условного перехода применяются сразу после команды CMP: CMP <оп1>, <оп2>. CMP работает так же, как и SUB, с тем отличием, что она изменяет только флаги. 

```asm
CMP EAX, EBX
JL l1 ; EAX<EBX
JA l2 ; EAX>EBX
JLE l3 ; EAX=EBX
```

Для беззнаковых операндов процессор проверяет флаг переноса, и флаг нуля, для знаковых - SF, OF, ZF.

Флаги DF, AF, TF используются при обработке массивов. TF - флаг трассировки, разрешает пошаговый режим отладки. После каждой выполненной инструкции происходит прерывание программы. 

BCD-числа - двоично-десятичные числа. 

#### Циклы

LOOP <метка>. Команда уменьшает содержимое ECX на 1, затем она сравнивает: если ECX > 0, то управление передается по метке, если ECX = 0, то то управление передается следующей команде. 

LOOPE/LOOPZ <метка> уменьшает ECX, и если ECX > 0 и ZF = 1, передает управление метке. Если ECX = 0 или ZF=0, то выполнить следующую команду. 

Команды для создания циклов (LOOP*) работают только в том случае, если в программе только небольшие переходы (не больше 128 байт). 

```asm
XOR ESI, ESI
MOV ECX, 9
start:
MOV EBX, ECX
ADD EBX, 1
MOV EAX, EBX
MUL EBX
ADD ESI, EBX
LOOP start

или

XOR ESI, ESI
MOV EBX, 1
l1:
MOV EAX, EBX
IMUL EAX
ADD ESI, EAX
INC EBX
CMP EBX, 0
JLE l1

```

