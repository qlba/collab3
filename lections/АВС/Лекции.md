## Лекция 1

### История развития вычислительной технический

#### **I** поколение ЭВМ (1950-е гг) было построено на базе электронных ламп
Электронная лампа - электровакуумный прибор, предназначенный для генерации, усиления и преобразования электрических сигналов.
Примеры систем: ENIAC, БЭСМ
Основоположник вычислительной техники в СССР - академик Лебедев С. А.

#### **II** поколение ведет историю с изобретения транзистора в 1948-м году.

> Транзистор - полупроводниковый прибор с тремя контактами, предназначенный для генерирования и преобразования электрических сигналов. Транзистор способен работать за 40 электронных ламп, с большей скоростью, потреблять меньше энергии.

Примеры систем: БЭСМ-6, Стретч (Англия), Атлас (США)
БЭСМ-6 состояла из 60 тыс. транзисторов и 180 тыс. диодов. Производительность - 1 млн операций в секунду.

#### **III** поколение - интегральные схемы.

> Одна интегральная схема может заменить несколько тысяч транзисторов (или несколько сорок тысяч ламп), обеспечивает стократный прирост производительности и уменьшение тепловыделения.

ИС изготавливают из особо чистых полупроводниковых материалов (кремний или германий). На основу наносятся химические элементы таким образом, что они образуют узлы сложной схемы.

#### **IV** поколение - сверхбольшие интегральные схемы (СБИС)

Технологический процесс определяет размер транзистора (затвора). В настоящее время освоена технология производства транзисторов от 5 нм.

Закон Мура. Гордон Мур сделал наблюдение, что каждые 18-24 месяца количество транзисторов в электронных устройствах возрастает вдвое.

#### **V** поколение ЭВМ
связывают с разработкой систем искуственного интеллекта и появлением квантовых процессоров

Быстродействие вычислительной системы в конечном итоге зависит от:
1. Технологии производства микросхем, процессоров, памяти, архитектуры.
2. Эффективности компиляторов

### Архитектура Джона фон Неймана

**Архитектура вычислительной системы** - это описание вычислительной системы на общем уровне, включающий систему команд, средства пользовательского интерфейса, организацию памяти. Архитектура определяет, из каких узлов будет состоять вычислительная система.

Абсолютное большинство вычислительных систем построены на архитектуре фон Неймана.

![Архитектура фон Неймана](files/l1pic1.png)

Центральный процессор состоит из двух блоков:
-   АЛУ (арифметико-логическое устройство)
-   УУ  (устройство управления)

Устройство управления определяет порядок выполнения процессором операций.
Арифметико-логическое устройство - блок процессора, который выполняет арифметические и логические операции.
УУ в каждый момент времени определяет, какую операцию выполнять следующей.

Устройство управления выбирает команды из оперативной памяти. Все данные для обработки попадают в процессор также через оперативную память.
## Лекция 2

### Принципы функционирования центрального процессора

**Машинная команда** - это описание операции, которую должна выполнить ЭВМ, закодированное в двоичном виде. Содержит выполняемые операции и коды операндов (адреса ячеек оперативной памяти). Команды бывают следующих видов: 

1. Арифметические (сложение, вычитание, умножение, деление - ADD, SUB, MUL, DIV)
2. Логические (и, или, исключающее или, отрицание - AND, OR, XOR, NOT)
3. Команды ввода-вывода (ввод, вывод с помощью портов - IN, OUT)
4. Команды перехода и вызова подпрограмм (JMP, CALL,LOOP, JLE, JOP, и т. д.)
5. Команды для работы с прерываниями

Совокупность операций, выполняемых процессором, называется *система команд*.  Мы будем изучать систему команд x86.

**Регистры** - это ячейки быстродействующей памяти, расположенные непосредственно на кристалле процессора. 

картинка 1

Аналогичную структуру имеют регистры **RBX, RCX, RDX**. В 64-битной архитектуре добавлены восемь новых регистров: **R0-R7**. 

### Работа с регистрами

Очищать регистры можно с помощью XOR. XOR EAX, EAX даст 0 в EAX. Эта команда занимает меньше места и выполняется быстрее, чем MOV EAX, 0. Чтобы заполнить регистр единицами, можно записать в него 0FFFFFFFFh - самое большое возможное число.

Пара примеров:

```asm
MOV EAX, 0FFFFFFFFh

ADD EAX, 1 ; EAX = 000000000h, т.к. произошел перенос

ADD AX, 1 ; EAX = 0FFFF0000h, т.к. произошел перенос (но мы работали с 16-ричным разрядом).
```

При возникновении переноса устанавливается флаг переноса CF.

Надо помнить, что 16-ричной системе счисления 1 байт = 2 цифры. $FF_{16}=255_{10}$. Тетрада - набор из четырех бит, обозначается одной шестнадцатеричной цифрой.

Любая команда процессора работает только с той частью регистра, которая указана в ее описании. 

Программисту доступны регистры общего назначения EAX, EBX, ECX, EDX, индексные ESI, EDI и регистр EBP. Индексные регистры чаще используют для работы с массивами, в них записывают адреса ячеек оперативной памяти. EBP обычно используется компиляторами для адресации аргументов функций и локальных переменных, но программист может их использовать по собственному усмотрению. ESP - указатель на вершину стека. 

#### Назначение стека

1. В стеке хранятся локальные переменные
2. При вызове подпрограмм в стек сохраняется адрес возврата из подпрограммы.
3. В стек обычно передаются аргументы подпрограммы.

Размер стека небольшой, порядка нескольких мегабайт.

**EIP** указывает на текущую выполняемую инструкцию, увеличивается на размер выполненной команды.

**EFLAGS** - 32-битный регистр, который содержит несколько флагов - переноса, переполнения, четности, направления, трассировки и другие. 
**Флаг** - однобитный регистр, в котором сохраняется информация о выполнении последней команды. То есть, флаги отражают текущее состояние процессора. 

**Сегментные регистры** - шестнадцатиразрядные регистры.

- CS (code segment) содержит номер сегмента кода, с которым работает программа.
- DS (data segment) - номер сегмента данных
- SS (stack segment) - номер сегмента стека
- ES
- FS

В операционной системе Windows используется сплошная модель памяти, поэтому данные, код и стек располагаются в одном адресном пространстве.

#### Директивы для определения переменных:

Типы данных:

- DB - 1 байт, char
- DW - 2 слово, short
- DD - 4 двойное слово, int
- DF - 6 тройное слово long double
- DQ - 8 учетверенное слово, long long
- DT - 10 упятеренное слово

Вещественные числа могут храниться как четырехбайтовые и восьмибайтовые. Некоторые команды процессора требуют указания размера аргумента. (Аналог приведения типа). Для этого используются  директивы приведения типа:

- byte ptr - 1 байт
- word ptr - слово
- dword ptr - 4 байта
- qword ptr - 8 байт

## Лекция 3

### Виды адресации

1. Непосредственная адресация
   MOV EAX, 10
   Непосредственную адресацию здесь имеет операнд 10. EAX - регистровая адресация.
2. Регистровая адресация
   ADD ESI, EDI
   Оба операнда имеют регистровую адресацию.
3. Прямая адресация
   В данном случае операнд располагается в оперативной памяти.
   MOV EAX, [04001002]
   c dd 6
   MOV EBX, c
   Два способа выше эквивалентны, т.к. вместо переменной c подставляется адрес в памяти
4. Базовая адресация
   Адрес ячейки записан в одном регистре
   MOV ESI, [EBX]
   В ассемблере невозможны команды, при которых обе ячейки имеют базовую адресацию. Один из операторов обязательно должен иметь либо регистровую адресацию, или  непосредственную.
   char a[]={1,2,3}
   MOV ESI, offset a
   MOV a, ESI
   MOV AL, a[0]
   MOV AL, [ESI]
5. Базово-индексная адресация
   В формировании адреса участвуют два регистра.
   MOV ESI, [EBX+EDI]
   Такая адресация полезна при адресации массивов.
6. Базово-индексная с масштабированием
   MOV ESI, [EBX+EDI * 4]
   То же, что и 5, но прибавляемое значение умножается.
   Масштабный множитель может быть равен 1, 2, 4 либо 8
   int a = {1, 2, 3}
   MOV ESI, offset a
   LEA ESI, [EAX+EAX * 4]; ESI = EAX+EAX * 4 = EAX * 5
   Такой способ удобен для обхода массивов для типов char, short, int, float, double
   a dd 1, 2, 3, 4 ; один элемент занимает 4 байта
   MOV EAX, a ; запишется 1
   MOV EAX, a[0] ; то же самое
   MOV EBX, a[4] ; запишется 2

В оперативной памяти байты чисел хранятся по следующему правилу: младший байт - по младшему адресу, т.е., порядок Little Endian.
Если необходимо получить в регистре адрес ячейки памяти, можно использовать директиву offset. Запишем в ESI адрес массива a:
MOV ESI, offset a.

Если нужно сохранить данные в виде матрицы, необходимо представить ее в виде массива, в таком виде записать ее в памяти и интерпретировать как матрицу.

### Арифметические команды

Процессор не разделяет знаковые и беззнаковые числа в операциях сложения и вычитания. 
Процессор складывает числа в кольце целых чисел по модулю (2^8, 2^16, 2^32). 
При работе со знаковыми числами пользователь (программист) сам интерпретирует числа со старшим единичным битом как отрицательные.

ADD <операнд1>, <операнд2>
Складывает два операнда
ADC <операнд1>, <операнд2>
Кроме сложения операндов добавляет флаг CF.

```asm
MOV AL, 255
XOR BL, BL
ADD AL, 2 ; AL = 1, CF = 1
ADC BL, 0 ; BL = 1
```

INC <операнд>
Инкрементирует операнд, при переполнении устанавливает флаг

Эти команды складывают как числа со знаком, так и без знака.

SUB <операнд1>, <операнд2> - вычитание
SBB <операнд1>, <операнд2> - вычитание со знаком переноса
DEC <операнд> - декремент